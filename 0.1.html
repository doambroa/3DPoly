<!DOCTYPE html>

<html>

<head>
	<meta charset="utf-8">

	<title>Visualizador WebGL de OBJ usando Three.js</title>

	<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
	</style>
	
	<script src="js/three.min.js"></script>
	<!--<script src="js/TrackballControls.js"></script>-->
	<script src="js/OrbitControls.js"></script>
	<script src="js/ImageUtils.js"></script>
	<script src="js/MTLLoader.js"></script>
	<script src="js/OBJMTLLoader.js"></script>
	<script src="js/dat.gui.js"></script>

	<!--<script src="js/Detector.js"></script>-->
</head>

<body>
<script>
	var canvas; //antes le llamaba container porque contenía la escena
	var camera;
	var controls;
	var scene;
	var renderer;
	var mouseX = 0;
	var mouseY = 0;
	var ambient; //luz de ambiente
	var aspectRatio = window.innerWidth / window.innerHeight;
	//posible niebla para la fachada
	//var niebla = new THREE.Fog(0xCCFFCC, 1, 1000);
	var CuadroMenu = function() {
	  this.mensaje = 'Prueba Menú';
	  this.Tamaño = 0.8;
	  this.Despachos = false;
	  this.Aulas_de_teoría = false;
	  this.Aseos = false;
	  this.Evacuación = false;
	  this.color = "#ffd100";
	  this.VelocidadRotacion = 1;

	};

	//INICIALIZACIÓN
	function init()
	{
		//div para el elemento canvas de la escena
		canvas = document.createElement('div');
		document.body.appendChild( canvas );




	window.onload = function() {
	  var text = new CuadroMenu();
	  var gui = new dat.GUI();

	  //estructura de carpetas del menú

	var f1 = gui.addFolder('Planta 1');
	//f1.open();

	var f2 = gui.addFolder('Planta 2');
	f2.add(text, 'VelocidadRotacion', -10, 10)
	f2.add(text, 'Despachos');
	f2.add(text, 'Evacuación');
	f2.add(text, 'Aulas_de_teoría');
	f2.open();
/*
	 this.color0 = "#ffae23"; // string de CSS
	  this.color1 = [ 0, 128, 255 ]; //  array RGB
	  this.color2 = [ 0, 128, 255, 0.3 ]; // RGB con alpha añadido
	  this.color3 = { h: 350, s: 0.9, v: 0.3 }; // Hue, saturatción, valor
*/

	  gui.add(text, 'mensaje');
	  f1.add(text, 'Tamaño', -5, 5);
	  f2.add(text, 'Despachos');
	  f1.add(text, 'Aseos')
	  gui.addColor(text, 'color')
	};
	

	
		//Ajustamos la distancia de la cámara, nuestro campo de visión
		// THREE.PerspectiveCamera(ÁnguloDeVisión, AspectRatio, cercano, lejano)
		camera = new THREE.PerspectiveCamera(45	, aspectRatio, 1, 100000);
		camera.position.z = 550	;

		renderer = new THREE.WebGLRenderer({});

		//Comportamiento y sensibilidad de la cámara
		controls = new THREE.OrbitControls( camera, document, renderer.domElement );
		
		controls.rotateSpeed = 1.0;
		controls.zoomSpeed = 1.0;
		controls.panSpeed = 1; //no funciona
		controls.noZoom = false;
		controls.noPan = false;
		controls.staticMoving = false; //con el cambio a Orbitcontrols la fluidez se pierde indiferentemente de este valor
		controls.dynamicDampingFactor = 0.3;



		// Creamos la escena para añadirle los elementos
		scene = new THREE.Scene();
		ambient = new THREE.AmbientLight(0xFFFFFA); //casi negra
		scene.add( ambient ); //añadimos la luz de ambiente a la escena
		  // Luz direccional simple, para ver los sombreados.
  		var directionalLight = new THREE.DirectionalLight( 0xffeedd );
  		 directionalLight.position.set( 0, 0, 1 ).normalize(); //de frente a la escena
  		 scene.add( directionalLight );

  		 scene.add( camera );

  		 THREE.ImageUtils.crossOrigin = "anonymous"; //para que el origen de las imagenes pueda ser diferente al de origen (no corrige 403)


  		//Carga de Modelo
				var loader = new THREE.OBJMTLLoader();
				loader.load( 'models/b.obj', 'models/textures/b.mtl', function ( object ){
					
					
					object.position.set(0,0,0);
					object.position.y = -80;
					object.name = 'edificio';

					scene.add(object);

});
				
			/// FIN DE CARGA DEL OBJ ///

			//Al tener tantas texturas distintas creo que MTL es lo idóneo, pero quizá me interese cambiarlo a la laga por algo del estilo zmesh = new THREE.Mesh( geometry,new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture(tmap)})); Usando imageUtils.

			
		//Ponemos el renderer al tamaño de la ventana y lo incluimos en el HTML
		
		renderer.setSize( window.innerWidth, window.innerHeight );
		canvas.appendChild( renderer.domElement );

		window.addEventListener( 'resize', onWindowResize, false );

	
	}


	/// BUCLE DE RENDERIZACIÓN ///
	function animate()
	{
		//Se llama a sí misma con cada fotograma, se puede cambiar la 
		//rotación del objeto en cada llamada para crear una animación de giro
		//nos da una frecuencia de 60 fps automáticamente sin necesidad de setInterval.
		//Además si el usuario cambia de pestaña, la función se detiene, con lo que ahorra
		//batería y procesamiento.
		requestAnimationFrame( animate );

		controls.update();
		
		//camera.lookAt(scene.position); //si lo dejase activado la camara miraría todo el rato a la escena y se hace un lío sin dejarme hacer correctamente el Pan. Una vez quitado el Pan ya va mas o menos bien.
		
		//Aquí tendré que poner las directivas de acción de los filtros o las 
		//llamadas a las funciones de los filtros porque son activados durante la visualización del modelado.

		
		render();
	}

	function onWindowResize() 
	{
	    camera.aspect = window.innerWidth / window.innerHeight; //no puede ser aspectRatio porque se tiene que recalcular en cada llamada
    	camera.updateProjectionMatrix();

    	renderer.setSize(window.innerWidth, window.innerHeight);

    	// no me hace falta controls.handleResize();
    	render();
}

	function render()
	{
		renderer.render(scene, camera);
	}


init();
animate();

</script>

</body>

</html>